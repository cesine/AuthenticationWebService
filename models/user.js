var bcrypt = require('bcrypt');
var crypto = require('crypto');
var debug = require('debug')('user');
var lodash = require('lodash');
var Sequelize = require('sequelize');

var sequelize = new Sequelize('database', 'username', 'password', {
  dialect: 'sqlite',
  pool: {
    max: 5,
    min: 0,
    idle: 10000
  },
  storage: 'db/users.sqlite'
});

var DEFAULT_GRAVATAR = '9a85e3d0-4233-11e6-bac0-4b263459491d';

/*
 * Add new properties to the flat schema
 */
var FLAT_SCHEMA = {
  id: {
    type: Sequelize.UUID,
    defaultValue: Sequelize.UUIDV1,
    primaryKey: true
  },
  revision: Sequelize.STRING,
  deletedAt: Sequelize.DATE,
  deletedReason: Sequelize.STRING,
  username: {
    type: Sequelize.STRING,
    unique: true
  },
  email: Sequelize.STRING,
  gravatar: {
    type: Sequelize.STRING,
    get: function getGravatar() {
      var gravatar = this.getDataValue('gravatar');
      var email;
      if (gravatar) {
        return gravatar;
      }
      email = this.getDataValue('email') || this.getDataValue('id') || DEFAULT_GRAVATAR;
      return crypto.createHash('md5').update(email).digest('hex');
    }
  },
  description: Sequelize.TEXT,
  givenName: Sequelize.STRING,
  familyName: Sequelize.STRING,
  language: Sequelize.STRING,
  hash: Sequelize.STRING
};

var User = sequelize.define('users', FLAT_SCHEMA);

/**
 * Convert an incoming json and scrubs it against the above SCHEMA
 * @param  {Object} json A user profile usually coming from the client side for example
 * @return {Object}      A flat representation of the user which can be saved in the db
 */
function jsonToFlat(json, defaultValue) {
  var flat = {};

  Object.keys(FLAT_SCHEMA).forEach(function forEachKey(attr) {
    if (attr.indexOf('Name') > -1) {
      flat[attr] = (json.name && json.name[attr] !== undefined && json.name[attr] !== null)
        ? json.name[attr] : defaultValue;
    } else {
      flat[attr] = json[attr] !== undefined && json[attr] !== null
        ? json[attr] : defaultValue;
    }
  });

  // use autogenerated id
  if (!flat.id) {
    delete flat.id;
  }

  if (!flat.deletedAt) {
    flat.deletedAt = null;
  }

  if (flat.password) {
    // TODO
  }

  return flat;
}

/**
 * Convert a flat object from the database to a Passport compatible
 * user profile
 * @param  {Object} flat A flat representation usualy from the db
 * @return {Object}      A Passport compatible representation of the user
 */
function flatToJson(flat, defaultValue) {
  var json = {
    name: {}
  };

  Object.keys(FLAT_SCHEMA).forEach(function forEachKey(attr) {
    if (attr.indexOf('Name') > -1) {
      json.name[attr] = flat[attr] !== undefined && flat[attr] !== null
        ? flat[attr] : defaultValue;
    } else {
      json[attr] = flat[attr] !== undefined && flat[attr] !== null
        ? flat[attr] : defaultValue;
    }
  });

  if (!json.deletedAt) {
    json.deletedAt = null;
  }

  if (flat.createdAt) {
    json.createdAt = flat.createdAt;
  }

  if (flat.updatedAt) {
    json.updatedAt = flat.updatedAt;
  }

  return json;
}

function increaseRevision(revision) {
  var revisionNumber = parseInt(revision.split('-')[0], 10);
  return (revisionNumber + 1) + '-' + Date.now();
}

/**
 * Verify a user in the database
 * @param  {User}   profile
 * @return {Promise}
 */
function hashPassword(password) {
  var salt;
  if (!password) {
    return new Error('Please provide a password');
  }

  salt = bcrypt.genSaltSync(10);
  return {
    salt: salt,
    hash: bcrypt.hashSync(password, salt)
  };
}

/**
 * Create a user in the database
 * @param  {User}   profile
 * @return {Promise}
 */
function create(profile, callback) {
  var flat;
  var hashed;

  if (!profile) {
    return callback(new Error('Please provide a user'));
  }

  if (!profile || !profile.password || profile.password.length < 8) {
    return callback(new Error('Please provide a password which is 8 characters or longer'));
  }

  // eslint-disable-next-line no-param-reassign
  delete profile.hash;

  flat = jsonToFlat(profile);

  if (flat.revision) {
    if (flat.revision.indexOf('-') === -1) {
      delete flat.revision;
    } else {
      flat.revision = increaseRevision(flat.revision);
    }
  }
  flat.revision = flat.revision || '1-' + Date.now();

  hashed = hashPassword(profile.password);
  // eslint-disable-next-line no-param-reassign
  delete profile.password;
  if (hashed instanceof Error) {
    return callback(hashed);
  }

  flat.hash = hashed.hash;

  return User
    .create(flat)
    .then(function whenCreated(data) {
      flat = data.toJSON();
      return callback(null, flatToJson(flat, ''));
    })
    .catch(callback);
}

/**
 * Create a user in the database
 * @param  {User}   profile
 * @return {Promise}
 */
function read(profile, callback) {
  return User
    .find({
      where: {
        username: profile.username
      }
    })
    .then(function whenFound(dbUser) {
      if (!dbUser) {
        return callback(null, null);
      }
      return callback(null, flatToJson(dbUser.toJSON(), ''));
    })
    .catch(callback);
}

/**
 * Verify a user in the database
 * @param  {User}   profile
 * @return {Promise}
 */
function verifyPassword(profile, callback) {
  if (!profile || !profile.username || !profile.password) {
    return callback(new Error('Please provide a username and a password'));
  }

  return User
    .find({
      where: {
        username: profile.username
      }
      // attributes: ['hash']
    })
    .then(function whenFound(dbUser) {
      if (!dbUser) {
        return callback(new Error('User not found'));
      }

      if (!dbUser.dataValues.hash) {
        return callback(new Error('User doesn\'t have a password'));
      }

      if (bcrypt.compareSync(profile.password, dbUser.dataValues.hash)) {
        return callback(null, flatToJson(dbUser.toJSON(), ''));
      }

      return callback(new Error('Invalid password'));
    })
    .catch(callback);
}

/**
 * Verify a user in the database
 * @param  {User}   profile
 * @return {Promise}
 */
function changePassword(profile, callback) {
  if (!profile || !profile.username || !profile.newPassword || !profile.password) {
    return callback(new Error('Please provide a username, password and newPassword'));
  }

  return User
    .find({
      where: {
        username: profile.username
      }
    })
    .then(function whenFound(dbUser) {
      var hashed;
      if (!dbUser.dataValues.hash) {
        return callback(new Error('Password was not set, please report this 34544.'));
      }

      if (!bcrypt.compareSync(profile.password, dbUser.dataValues.hash)) {
        debug('user', profile);
        debug('dbUser', dbUser);
        return callback(new Error('Password doesn\'t match your old password'));
      }

      hashed = hashPassword(profile.newPassword);
      // eslint-disable-next-line no-param-reassign
      delete profile.password;
      // eslint-disable-next-line no-param-reassign
      delete profile.newPassword;
      if (hashed instanceof Error) {
        return callback(hashed);
      }

      // eslint-disable-next-line no-param-reassign
      dbUser.dataValues.hash = hashed.hash;
      return dbUser.save().then(function whenSaved(savedDbUser) {
        return callback(null, flatToJson(savedDbUser.toJSON(), ''));
      }).catch(callback);
    })
    .catch(callback);
}

/**
 * Save a user in the database
 * @param  {User}   profile
 * @return {Promise}
 */
function save(profile, callback) {
  if (!profile) {
    return callback(new Error('Please provide a user'));
  }

  return User
    .find({
      where: {
        username: profile.username
      }
    })
    .then(function whenFound(dbUser) {
      var flat;
      var hashed;
      // Create the user
      if (!dbUser) {
        return create(profile, callback);
      }

      // eslint-disable-next-line no-param-reassign
      delete profile.hash;
      // eslint-disable-next-line no-param-reassign
      delete profile.password;

      flat = jsonToFlat(profile, 'not:::patched');
      debug(flat);

      // Update only the changed fields
      Object.keys(flat).forEach(function forEachKey(attr) {
        if (flat[attr] !== 'not:::patched') {
          dbUser.set(attr, flat[attr]);
          debug('setting ', attr);
        }
      });

      // If the user doesnt have a has yet
      // and the passed in profile had a password,
      // set the hash
      if (profile.password && !dbUser.dataValues.hash) {
        hashed = hashPassword(profile.password);
        if (hashed instanceof Error) {
          return callback(hashed);
        }

        // eslint-disable-next-line no-param-reassign
        dbUser.hash = hashed.hash;
      }

      dbUser.set('revision', increaseRevision(dbUser.get('revision')));

      return dbUser
        .save()
        .then(function whenSaved(savedDbUser) {
          debug(savedDbUser);
          if (!savedDbUser) {
            return callback(new Error('Unable to save the user.'));
          }

          return callback(null, flatToJson(savedDbUser.toJSON(), ''));
        })
        .catch(callback);
    })
    .catch(callback);
}

/**
 * List users matching the options
 * @param  {String} options [description]
 * @return {Promise}        [description]
 */
function list(options, callback) {
  var opts = lodash.assign({
    limit: 10,
    offset: 0,
    where: {
      deletedAt: null
    }
  }, options);
  opts.attributes = ['id', 'username', 'gravatar'];

  return User
    .findAll(opts)
    .then(function whenFound(users) {
      if (!users) {
        return callback(new Error('Unable to fetch user collection'));
      }

      return callback(null, users.map(function mapToJson(dbUser) {
        return dbUser.toJSON();
      }));
    })
    .catch(callback);
}

/**
 * Delete users matching the options
 * @param  {String} options [description]
 * @return {Promise}        [description]
 */
function flagAsDeleted(profile, callback) {
  if (!profile || !profile.username || !profile.deletedReason) {
    return callback(new Error('Please provide a username and a deletedReason'));
  }

  return User
    .find({
      where: {
        username: profile.username
      }
    })
    .then(function whenFound(dbUser) {
      if (!dbUser) {
        return callback(new Error('Cannot delete user which doesn\'t exist'));
      }

      // eslint-disable-next-line no-param-reassign
      dbUser.deletedAt = new Date();
      // eslint-disable-next-line no-param-reassign
      dbUser.deletedReason = profile.deletedReason;

      return dbUser
        .save(dbUser)
        .then(function whenSaved(savedDbUser) {
          if (!savedDbUser) {
            return callback(new Error('Save failed'));
          }

          return callback(null, savedDbUser.toJSON());
        })
        .catch(callback);
    });
}

/**
 * Initialize the table if not already present
 * @return {Promise}        [description]
 */
function init() {
  return sequelize.sync();
}

module.exports.create = create;
module.exports.flagAsDeleted = flagAsDeleted;
module.exports.init = init;
module.exports.list = list;
module.exports.save = save;
module.exports.read = read;
module.exports.hashPassword = hashPassword;
module.exports.changePassword = changePassword;
module.exports.verifyPassword = verifyPassword;
module.exports.serialization = {
  flatToJson: flatToJson,
  jsonToFlat: jsonToFlat
};
